IF DEBUG_DIRTY_FLASH
    DIRTY_FLASHER_INIT: EQU %10101010
    temp_dirty_flasher: defb DIRTY_FLASHER_INIT  ; bit pattern for flashing (bits are rotated)
    FLASH: equ 255  ; what to flash with

    dirty_flasher:
                ; using a counter, flipflop the actual data with something else
                ; to visually indicate which areas are being redrawn
                push hl
                ld hl, temp_dirty_flasher
                bit 0, (hl)
                jr z, @+no_flash
                ld a, FLASH
        @no_flash:
                pop hl
                ret

    update_dirty_flasher:
                ld hl, temp_dirty_flasher
                rrc (hl)
                ret

    reset_dirty_flasher:
                ld hl, temp_dirty_flasher
                ld (hl), DIRTY_FLASHER_INIT
                ret
ENDIF


box_at_hl:
                ; modifies bc, hl
                ; draw just a square outline box (used for the cursor)
                ; using color nibble passed in A register
                ; on entry, hl = screen location for drawing the box
                IF DEBUG_DIRTY_FLASH
                call dirty_flasher
                ENDIF

                ; draw top (left to right)
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                ; draw right side (downwards)
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                ; draw left side (upwards)
                ld b, a
                ld a, l
                sub 7
                ld l, a
                ld a, b
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ; draw odd left side (downwards)
                ld a, l
                add 128
                ld l, a
                ld a, h
                adc 0
                ld h, a

                ld a, b
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ld (hl), a
                inc h
                ; draw bottom
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                inc l
                ld (hl), a
                ; draw right side (upwards)
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                dec h
                ld (hl), a
                ret

; TODO
; need a vertical slice, horizontal slice, and full 16x16 rect fill
; vertical slice is for horizontal sliders;
; horizontal slice is for vertical sliders and falling blocks;
; full 16x16 rect fill is for shoving a block left or right, and for cursor itself.
; can optimize later
fillrect_16x16_black_at_de:
                ; get a black (double) pixel
                xor a
                ;IF DEBUG_DIRTY_FLASH
                ;call dirty_flasher
                ;ENDIF

                jp fillrect_16x16_de_colorbyte_a


_draw_debug_tile_at_de_tile_a:
                ; modifies bc, de
                ; draw a fake tile, for debug purposes
                ; (just solid fill 16x16)
                ; on entry, de = screen buffer topleft corner of tile destination
                ; a = which tile to draw (0 = blank space, 1 = wall, 2 = triangle etc etc)
                ; multiply A by 17 to get a conveniently-coloured two-nibble (two pixel) value in A

                ld b,a
                sla a
                sla a
                sla a
                sla a
                add b

                ; fall through to:

fillrect_16x16_de_colorbyte_a:
                ; modifies bc, de
                ; draw a solid 16x16 using color byte A (two nibbles)
                ; step 1. left to right and right to left even rows
                ; moving down the screen (even rows only)
                ld b, 4
                ld c, a ; backup
    @evens:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                inc d
                djnz @-evens
                dec d

                ld a, e
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                ; step 2. left to right and right to left odd rows
                ; moving up the screen (odd rows only)
                ld a, c ; restore
                ld b, 4
    @odds:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                dec d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec d
                djnz @-odds
                ret


draw_tile_at_de_tile_a:
                ; modifies de, hl, bc
                ; on entry, de = screen buffer topleft corner of tile destination
                ; a = which tile to draw (0 = blank space, 1 = wall, 2 = triangle etc etc)
                ; w.r.t tile_bitmaps

                ; multiply a by 128 to get offset into bitmap data
                ld l, 0
                sra a ; shift lowest bit of a into c
                rr l ; shift c into l
                add a, tiles_bitmaps/256
                ld h,a
                ;ld hl, tiles_bitmaps
                ; fall through to:

draw_bitmap_16x16_hl_at_de:
                ; modifies de, hl, bc
                ; draws an unmasked full 16x16 bitmap onto screen
                ; bitmap is already in 'optimized' format (butterfly sequence)
                ; on entry, de = screen buffer topleft corner of tile destination
                ; hl = bitmap data (could be anything; probably a tile)

                ; step 1. draw left to right and right to left even rows
                ; moving down the screen (even rows only)

                IF DEBUG_DIRTY_FLASH
                ; using a counter, flipflop the actual data with something else
                ; to visually indicate which areas are being redrawn
                push hl
                ld hl, temp_dirty_flasher
                bit 0, (hl)
                pop hl
                jr z, @+_normal
                ld hl, tiles_bitmaps ; blank tile
            @_normal:
                ENDIF


                ld b, 4
    @evens:
                push bc
                LDI
                LDI
                LDI
                LDI
                LDI
                LDI
                LDI
                pop bc
                ld a, (hl)
                ld (de), a
                inc d
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                inc d
                inc hl
                djnz @-evens
                dec d

                ; move down one row of pixels
                ld a, e
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                ; step 2. draw left to right and right to left odd rows
                ; moving up the screen (odd rows only)
                ld b, 4
    @odds:
                push bc
                LDI
                LDI
                LDI
                LDI
                LDI
                LDI
                LDI
                pop bc
                ld a, (hl)
                ld (de), a
                dec d
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec e
                inc hl
                ld a, (hl)
                ld (de), a
                dec d
                inc hl
                djnz @-odds
                ret


fillrect_16x2_black_at_de:
                ; get a black (double) pixel
                xor a
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a

                ld a, e
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                xor a
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                ret

fillrect_16x1_black_at_de:
                ; get a black (double) pixel
                xor a
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                ret

fillrect_2x16_black_at_de:
                ; get a black (double) pixel
                xor a
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a
                inc d
                ld (de), a

                ld a, e
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                xor a
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                dec d
                ld (de), a
                ret


draw_masked_bitmap_32x16_hl_at_de:
                ; modifies hl, de, bc
                ; hl points to 32x16 bitmap with mask (first byte is mask, second byte is pixel data)
                ; de points to screen
                @pairs_down: equ FOR 4
                    @row_l_to_r: equ FOR 16
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    inc d
                    @row_r_to_l: equ FOR 16
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    inc d
                NEXT @pairs_down
                    dec d
                    ld a, e
                    add 128
                    ld e, a
                    ld a, d
                    adc 0
                    ld d, a
                @pairs_up: equ FOR 4
                    @row_l_to_r: equ FOR 16
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    dec d
                    @row_r_to_l: equ FOR 16
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    dec d
                NEXT @pairs_up
                ret

draw_masked_bitmap_16x16_hl_at_de:
                ; modifies hl, de, bc
                ; hl points to 16x16 bitmap with mask (first byte is mask, second byte is pixel data)
                ; de points to screen
                @pairs_down: equ FOR 4
                    @row_l_to_r: equ FOR 8
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    inc d
                    @row_r_to_l: equ FOR 8
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    inc d
                NEXT @pairs_down
                    dec d
                    ld a, e
                    add 128
                    ld e, a
                    ld a, d
                    adc 0
                    ld d, a
                @pairs_up: equ FOR 4
                    @row_l_to_r: equ FOR 8
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    dec d
                    @row_r_to_l: equ FOR 8
                    ld c, (hl)
                    inc hl
                    ld b, (hl)
                    inc hl
                    ld a, (de)
                    and c
                    or b
                    ld (de), a
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    dec d
                NEXT @pairs_up
                ret

fillrect_16x8_black_at_de:
                ; get a black (double) pixel
                xor a
                ld b, 2
    @evens:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                inc d
                djnz @-evens
                dec d

                ld a, e ; move down one row of pixels
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                xor a
                ld b, 2
    @odds:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                dec d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec d
                djnz @-odds
                ret

fillrect_8x8_black_at_de:
                ; get a black (double) pixel
                xor a
fillrect_8x8_de_colorbyte_a:
                push af
                ld b, 2
    @evens:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                inc d
                djnz @-evens
                dec d

                ld a, e ; move down one row of pixels
                add 128
                ld e, a
                ld a, d
                adc 0
                ld d, a

                pop af
                ld b, 2
    @odds:
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                inc e
                ld (de), a
                dec d
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec e
                ld (de), a
                dec d
                djnz @-odds
                ret

grid_xy_in_C_to_screen_de:
                ; modifies a, de
                ; Converts grid xy coords to screen memory in DE
                ; (pointing to top-left of that xy cell)
                ; multiply both grid x and grid y by 8 (and add GRID_X_OFFSET in x direction)
                ; and put into DE
                ; on entry: c = the YYYYxxxx grid coords
                ; Uses the assumption that grid is made up of 16x16 cells.

                ld a, c
grid_xy_in_C_and_A_to_screen_de:
                ; get x coord. we want to multiply x by 8 bytes (= 16 pixels)
                ; 16 pixels wide = multiply by 8
                and 15 ; a = xxxx
                add a, a ; a = x * 2
                add a, a; a = x * 4
                add a, a ; a = x * 8
                add GRID_X_OFFSET
                ld e, a ; e = x*8+GRID_X_OFFSET

                ; now get Y coord
                ; 16 pixels high = multiply by 8
                ; (since 256 bytes = 2 rows)
                ; A contains YYYYxxxx so to multiply Y by 8 we actually divide A by 2
                ld a, c ; YYYYxxxx
                and 240 ; a = YYYY0000 (i.e. 16*y , and we want 8*y). AND clears carry
                rra ; a = y * 8   really just srl a but rra is cheaper when carry is already clear
                ld d, a

                ; de is now pointing to top left xy on screen memory
                ret