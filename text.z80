; render simple text to screen

if DEBUG
; this version is for debug purposes right now
debug_digit_a_xy_de:
            ; modifies: hl, de, bc
            ; render bcd digit in a (0-9) to screen location at de
            ld h, digit_bitmap/256
            ; multiply a by 32 to get offset into table
            add a, a
            add a, a
            add a, a
            add a, a
            add a, a ; this might overflow
            ld l, a
            jr nc, @+nocarry
            inc h
    @nocarry:
            ld b, 8
    @outer:
            LDI
            LDI
            LDI
            LDI
            ld a, e
            add a, 124 ; 128 - 4 since we wrote 4 bytes
            ld e, a
            jr nc, @+nocarry
            inc d
    @nocarry:
            djnz @-outer
            ret            
ENDIF

digit_a_xy_de:
            ; modifies: hl, de, bc
            ; render bcd digit in a (0-9) to screen location at de
            ; TODO background bitmaps
            ; FOR NOW JUST FILL THE AREA
            ; !!!
            push af
            push de
            ld a, 0x66 ; RED
            call fillrect_8x8_de_colorbyte_a
            pop de
            pop af
            ; !!!

    ; ---
    ; drop shadow:
            push bc
            push de
            push af
            ; drop shadow is one pixel to the right (hence different font bitmap)
            ; and one pixel row lower; and black.
            ld c, 0 ; black
            ld b, a ; temp - A is "which digit to display" but we need to use A for some maths first
            ld a, e
            add 128
            ld e, a
            ld a, 0
            adc d
            ld d, a
            ld a, b ; temp restore
            ld h, digit_bitmap_shadow/256
            ; multiply a by 32 to get offset into table
            add a, a
            add a, a
            add a, a
            add a, a
            add a, a ; this might overflow
            ld l, a
            jr nc, @+no_carry
            inc h
        @no_carry:
            call char_hl_de
            pop af
            pop de
            pop bc
    ; end drop shadow
    ; ---

            ld h, digit_bitmap/256
            ; multiply a by 32 to get offset into table
            add a, a
            add a, a
            add a, a
            add a, a
            add a, a ; this might overflow
            ld l, a
            jr nc, char_hl_de
            inc h
            jp char_hl_de

alpha_a_xy_de_shadow:
            ld hl, alpha_bitmap_shadow
            jp @_alpha_a_xy_de_internal_common

alpha_a_xy_de:
            ; modifies: hl, de, bc
            ; render alphabetic character (upper ascii A=65 etc)
            ; to screen location at de
            ; to do, support more characters (need to finish bitmaps) but maybe ok for now

            ; multiply A by 32 to get offset into table
            ; into BC (i.e. BC = A*32)
            ; and add the base address in HL (alpha_bitmap)
            ;
            ; B        C            H        L
            ; 00000aaa AAA00000  +  hhhhhhhh llllllll
            ;
            ; since the first 32 values of A are unused (ASCII 0 to 31), the base address is oriented
            ; around A=32, so subtract 32 first
            ; Then, multiplying A by 32 is usually left-shift 5 times; but here we right-shift 3 times
            ; and shift the carry into the low byte (C)
            ;
            ; A = 00aaaAAA  =>  B = 00000aaa , C = AAA00000

            ld hl, alpha_bitmap
    @_alpha_a_xy_de_internal_common:
            push bc
            ld c, 0
            sub 32 ; now 0 <= A <= 64 , and also carry flag is cleared
            rra
            rr c
            rra
            rr c
            rra
            rr c
            ld b, a
            add hl, bc
            pop bc

char_hl_de:
            ; modifies: hl, de, bc
            ; render 8x8 mask char pointed to by hl, to screen memory pointed to by de
            ; The bitmap data is an (expanded) bitmask - each nibble will be either 0x0 or 0xF
            ; We mask the existing screen contents (using the inverse of the bitmap), and AND the
            ; bitmap with the colorbyte in C.
            ;
            ; small trick:
            ; We want to compute (s & ^m) | (c & m) (where s = existing screen bit, m = mask bit, c = color bit)
            ; across all 8 bits at a time (of course, only two pixels, but we can think of everything bitwise here)
            ; but, thinking one bit a time:
            ; s | m | c | bit
            ; --+---+---+----
            ; s | 0 | x | s
            ; x | 1 | c | c
            ;
            ; so what's the quickest way to do that?
            ;

            @pairs_down: equ FOR 2
                    @row_l_to_r: equ FOR 4
                    ld a, (hl)
                    and c
                    ld b, a ; b is now masked pixel to merge with (de)
                    ld a, (de)
                    cpl
                    or (hl)  ; the sequence "cpl or cpl" is equivalent to "and"ing with the inverted mask
                    cpl
                    or b
                    ld (de), a
                    inc hl
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    inc d
                    @row_r_to_l: equ FOR 4
                    ld a, (hl)
                    and c
                    ld b, a ; b is now masked pixel to merge with (de)
                    ld a, (de)
                    cpl
                    or (hl)  ; the sequence "cpl or cpl" is equivalent to "and"ing with the inverted mask
                    cpl
                    or b
                    ld (de), a
                    inc hl
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    inc d
                NEXT @pairs_down
                    dec d
                    ld a, e
                    add 128
                    ld e, a
                    ld a, d
                    adc 0
                    ld d, a
                @pairs_up: equ FOR 2
                    @row_l_to_r: equ FOR 4
                    ld a, (hl)
                    and c
                    ld b, a ; b is now masked pixel to merge with (de)
                    ld a, (de)
                    cpl
                    or (hl)  ; the sequence "cpl or cpl" is equivalent to "and"ing with the inverted mask
                    cpl
                    or b
                    ld (de), a
                    inc hl
                    inc e
                    NEXT @row_l_to_r
                    dec e
                    dec d
                    @row_r_to_l: equ FOR 4
                    ld a, (hl)
                    and c
                    ld b, a ; b is now masked pixel to merge with (de)
                    ld a, (de)
                    cpl
                    or (hl)  ; the sequence "cpl or cpl" is equivalent to "and"ing with the inverted mask
                    cpl
                    or b
                    ld (de), a
                    inc hl
                    dec e
                    NEXT @row_r_to_l
                    inc e
                    dec d
                NEXT @pairs_up
                ret

print_text_hl_de:
            ; print the message from hl, to screen location de,
            ; in color C (this is a colorbyte maskwith two nibbles so usually C = color x 17)
            ; message must be zero-terminated

    ; ---
    ; drop shadow:
            ld a, (hl)
            and a
            ret z
            push hl
            push de
            push bc
            ld c, 0
            ; drop shadow is one pixel to the right (hence different font bitmap)
            ; and one pixel row lower
            ld a, e
            add 128
            ld e, a
            ld a, 0
            adc d
            ld d, a
            ld a, (hl) ; annoying that we do this twice in this case
    @next_char:
            inc hl ; preincrement
            push hl
            push de
            call alpha_a_xy_de_shadow
            pop de
            pop hl
            ld a, (hl)  ; either this is next char, or nul terminator
            and a
            jr z, @+done
            ; go right 8 pixels
            inc e
            inc e
            inc e
            inc e
            jp @-next_char
    @done:
            pop bc
            pop de
            pop hl
    ; end drop shadow
    ; ---

            ld a, (hl)
            and a
            ret z
    @next_char:
            inc hl ; preincrement
            push hl
            push de
            call alpha_a_xy_de
            pop de
            pop hl
            ld a, (hl)  ; either this is next char, or nul terminator
            and a
            jr z, @+done
            ; go right 8 pixels
            inc e
            inc e
            inc e
            inc e
            jp @-next_char
    @done:
            ret


fatnum_digit_a_xy_de:
            ; modifies: hl, de, bc
            ; render bcd digit in a (0-9) to screen location at de
            ; fatnum digits are 16x16 with mask; so 16*16/2)*2 = 256 bytes  (handy!)
            ; TODO background bitmaps
            ; FOR NOW JUST FILL THE AREA
            ; !!!
            push af
            push de
            ld a, 0x66 ; RED
            call fillrect_16x16_de_colorbyte_a
            pop de
            pop af
            ; !!!

            add a, fatnums/256
            ld h, a
            ld l, 0
            jp draw_masked_bitmap_16x16_hl_at_de


ds ALIGN 256
; BEGIN DEBUG FONT (NUMBERS ONLY)
;             defb 0,255,255,0,  15, 0, 0, 240,  15, 0, 0, 240,  15, 0, 0, 240,  15, 0, 0, 240,  15, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 0
;             defb 0,0,240,0,   0,0,240,0,  0,0,240,0,  0,0,240,0,  0,0,240,0,  0,0,240,0,  0,0,240,0,  0, 0, 0, 0
;             defb 0,255,255,0,  0, 0, 0, 240,  0, 0, 0, 240,  0, 255, 255, 240,  15, 0, 0, 0,  15, 0, 0, 0,  15, 255, 255, 240,  0, 0, 0, 0
;             defb 0,255,255,0,  0, 0, 0, 240,  0, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 240,  0, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 0
;             defb 15,0,0,240,  15, 0, 0, 240,  15, 0, 0, 240,  15, 255, 255, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 0
;             defb 15,255,255,0,  15, 0, 0, 0,  15, 0, 0, 0,  15, 255, 255, 0,  0, 0, 0, 240,  0, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 0
;             defb 0,255,255,0,  15, 0, 0, 0,  15, 0, 0, 0,  15, 255, 255, 0,  15, 0, 0, 240,  15, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 0
;             defb 0,255,255,0,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 0
;             defb 0,255,255,0,  15, 0, 0, 240,  15, 0, 0, 240,  0, 255, 255, 0,  15, 0, 0, 240,  15, 0, 0, 240,  0, 255, 255, 0,  0, 0, 0, 0
;             defb 0,255,255,0,  15, 0, 0, 240,  15, 0, 0, 240,  0, 255, 255, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 240,  0, 0, 0, 0
; END DEBUG FONT (NUMBERS ONLY)
alpha_bitmap:
MDAT "alpha.b"
digit_bitmap: equ alpha_bitmap + 512 ; oh that's handy!

ds ALIGN 256
alpha_bitmap_shadow:
MDAT "alpha2.b"
digit_bitmap_shadow: equ alpha_bitmap_shadow + 512

ds ALIGN 256
fatnums:
MDAT "fatnums.b"