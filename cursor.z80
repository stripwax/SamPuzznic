draw_cursor:
                ; is the cursor on a tile with fire still held?
                ; if so, we follow the tile
                ld a, (controller_flags_tile_captured)
                and a
                jr z, @tile_not_captured
                ; TODO below doesn't work, needs debugging
                ; find the x or y offset of the tile and follow it.
                ; TODO optimise this. maybe we should just store offset (y*12+x)
                ld a, (controller_flags_x_pos)
                ld e, a
                ld a, (controller_flags_y_pos)
                ;; multiply a by 12
                ld d, a
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, (tiles-1)/256
                ; is tile falling
                ld a, (hl)
                bit 4, a
                jr z, @tile_not_captured ; tile isn't falling so y-offset is zero (TODO check sliders)
                ; get the offset for top-left into hl
    captured_cursor:
                and 15
                ld h, a
                ld l, 0
                srl h
                rl l
                ld a, (controller_flags_x_pos)
                ; 16 pixels wide = multiply by 8
                add a,a
                add a,a
                add a,a
                add 32
                add a, l ; <-- this is what's different
                ld l,a
                ld a, (controller_flags_y_pos)
                ; 16 pixels high = multiply by 8
                ; (since 256 bytes = 2 rows
                add a,a
                add a,a
                add a,a
                add a, h ; <-- this is what's different
                ld h, a
                jr @+draw_cursor
                ; .. TODO IMPLEMENT SLIDERS
                ; ...
                ; ...
@tile_not_captured:
                ld a, (controller_flags_x_pos)
                ; 16 pixels wide = multiply by 8
                add a,a
                add a,a
                add a,a
                add 32
                ld l,a
                ld a, (controller_flags_y_pos)
                ; 16 pixels high = multiply by 8
                ; (since 256 bytes = 2 rows
                add a,a
                add a,a
                add a,a
                ld h, a
                ; TODO only draw the cursor if the flashing counter tells us to
                ; i.e. redraw the title where the cursor would be,  the cursor is flashing
                ; what does that mean? well, if fire is held then we draw the cursor
                ; for four frames and then hide it for four frames, etc.  we have a ctr for it.
                ;ld a, (controller_flags_flashing_ctr)
                ;and 4
                ;ret nz ; four frames with bit cleared => draw cursor. four frames with bit set => don't draw cursor
                ; however we don't really want to have to draw the whole tile under the cursor, just the bit
                ; where the cursor is.
                ; so, cheat for now.  draw the cursor always, but in one of two colours.
                ; red usually, but white/red if flashing.
@draw_cursor:
                ld a, (controller_flags_flashing_ctr)
                and 4
                jr nz, @white
@red:
                ld a, palette_index_red * 17
                call box_at_hl
                ret
@white:
                ld a, palette_index_white * 17
                call box_at_hl
                ret


update_cursor_position:
    @check_fire:
                ; If fire is not held, then cursor moves up/down/left/right,
                ; subject to boundaries (i.e. cannot pass through tile==2)
                ;
                ; If fire is held, and the cell contains a tile, then you can only
                ; move left or right if the tile can move left or right
                ; NB CANNOT MOVE UP OR DOWN, WITH FIRE HELD!
                ;
                ; If fire is held, and the cell does not contain a tile, then cursor
                ; moves just as if fire is not held

                ld a, (controller_flags_fire)
                bit 0, a
                jp nz, @+check_dirs_with_fire_pressed
                ; fire was not pressed
                ; reset the flashing cursor counter
                ; reset the 'captured' flag
                xor a
                ld (controller_flags_tile_captured), a
                ld (controller_flags_flashing_ctr), a
    @movements_no_tile:
                ; either fire was not pressed (as fall through from above)
                ; or fire was pressed but we're not over a block that can move
    @check_directions:
                ld a, (controller_flags_dirs_acks)
                ; if NOTHING to do, do nothing
                and a
                ret z
    @check_up:
                ; was UP pressed?
                bit 0,a
                jr z, @+check_down ; no, up was not pressed
                bit 1,a
                ret nz ; yes, up was pressed but we already handled it earlier
                ; mark UP key as ackd (avoid repeats)
                or 2
                ld (controller_flags_dirs_acks), a
                ; get new position
                ; (first get current position)
                ld a, (controller_flags_x_pos)
                ld e, a
                ld a, (controller_flags_y_pos)
                dec a

                ; ; ----------
                ; ; if old y is zero, nothing to do, we can't go up
                ; ret c ; carry since if y was zero, decrementing would carry
                ; ; ----------
                ; pretty sure we don't need this since puzzles are surrounded by impenetrable blocks

                ; a = new y, e = x
                ; see if the tile in the new position is
                ; penetrable...
                ;; TODO OPTIMIZE
                ;; multiply a by 12
                ld d, a
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, tiles/256
                ld a, (hl)
                cp IMPENETRABLE_TILE ; 3 is the magic "wall that is impenetrable" tile
                ret z
                ; all good, we can move there
                ld a, d
                ld (controller_flags_y_pos), a
                ; mark the OLD location as dirty
                ; (old location was the row below this one)
                inc d
                call push_dirty_tile
                ret

    @check_down:
                ; was DOWN pressed?
                bit 2,a
                jr z, @+check_left ; no, down was not pressed
                bit 3,a
                ret nz ; yes, down was pressed but already handled
                ; mark DOWN key as ackd (avoid repeats)
                or 8
                ld (controller_flags_dirs_acks), a
                ; get new position
                ; (first get current position)
                ld a, (controller_flags_x_pos)
                ld e, a
                ld a, (controller_flags_y_pos)

                ; ----------
                ; ; if old y is at limit, nothing to do, we can't go down
                ; cp 11
                ; ret nc ; no carry since if y was 11 (or more), subtracting 11 would not carry
                ; ----------
                ; pretty sure we don't need this since puzzles are surrounded by impenetrable blocks

                inc a
                ; a = new y, e = x
                ; see if the tile in the new position is
                ; penetrable...
                ;; TODO OPTIMIZE
                ;; multiply a by 12
                ld d, a
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, tiles/256
                ld a, (hl)
                cp IMPENETRABLE_TILE ; 3 is the magic "wall that is impenetrable" tile
                ret z
                ; all good, we can move there
                ld a, d
                ld (controller_flags_y_pos), a
                ; mark the OLD location as dirty
                ; (old location was the row above this one)
                dec d
                call push_dirty_tile
                ret

    @check_left:
                ; was LEFT pressed 
                bit 4,a
                jr z, @+check_right ; no
                bit 5,a
                ret nz ; yes but handled already
                ; mark LEFT key as ackd (avoid repeats)
                or 32
                ld (controller_flags_dirs_acks), a
                ; get new position
                ; (first get current position)
                ld a, (controller_flags_x_pos)
                ld e, a
                dec e

                ; ----------
                ; ; if old x is at limit, nothing to do, we can't go left
                ; ret c ; carry since if x was zero, decrementing would carry
                ; ----------
                ; pretty sure we don't need this since puzzles are surrounded by impenetrable blocks

                ld a, (controller_flags_y_pos)
                ld d, a
                ; a = new x, d = y
                ; see if the tile in the new position is
                ; penetrable...
                ;; TODO OPTIMIZE
                ;; multiply d by 12
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, tiles/256
                ld a, (hl)
                cp IMPENETRABLE_TILE ; 3 is the magic "wall that is impenetrable" tile
                ret z
                ; all good, we can move there
                ld a, e
                ld (controller_flags_x_pos), a
                ; mark the OLD location as dirty
                ; (old location was the column right of this one)
                inc e
                call push_dirty_tile
                ret

    @check_right:
                ; was RIGHT pressed?
                bit 6,a
                ; ; jr z, @+done ; no ; TODO OPTIMIZE AS RET Z
                ret z
                bit 7,a
                ret nz ; yes but handled already ; TODO OPTIMIZE AS RET NZ
                ; mark RIGHT key as ackd (avoid repeats)
                or 128
                ld (controller_flags_dirs_acks), a
                ; get new position
                ; (first get current position)
                ld a, (controller_flags_x_pos)

                ; ----------
                ; ; if old x is at limit, nothing to do, we can't go right
                ; cp 9
                ; ret nc ; no carry since if x was 9 (or more), subtracting 9 would not carry
                ; ----------
                ; pretty sure we don't need this since puzzles are surrounded by impenetrable blocks

                ld e, a
                inc e
                ld a, (controller_flags_y_pos)
                ld d, a
                ; a = new x, d = y
                ; see if the tile in the new position is
                ; penetrable...
                ;; TODO OPTIMIZE
                ;; multiply d by 12
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, tiles/256
                ld a, (hl)
                cp IMPENETRABLE_TILE ; 3 is the magic "wall that is impenetrable" tile
                ret z
                ; all good, we can move there
                ld a, e
                ld (controller_flags_x_pos), a
                ; mark the OLD location as dirty
                ; (old location was the column left of this one)
                dec e
                call push_dirty_tile
                ret

    @check_dirs_with_fire_pressed:
                ; first some admin:
                ; FIRE is held down - so increment frame counter for flashing
                ; cursor if the flag for 'is captured' is already set
                ; (implying it is "still" held down)
                ld a, (controller_flags_tile_captured)
                and a
                jr z, @+skip
                ld a, (controller_flags_flashing_ctr)
                inc a
        @skip:
                ; (flashing_ctr is either incremented, or zero. neat.)
                ld (controller_flags_flashing_ctr), a

                ; Now for the movement (i.e. push left / push right)
                ; There are a lot of cases to consider here
                ; TODO optimise.  We should be able to make determination here pretty
                ; quickly, and right know there's quite a lot of back-and-forth
                ; and repeated multiplying-by-12 steps going on.

                ; 1. determine if there is a (movable) tile at current position
                ; (first get current position)
                ld a, (controller_flags_x_pos)
                ld e, a
                ld a, (controller_flags_y_pos)
                ld d, a
                ; a = e = x, d = y
                ;; TODO OPTIMIZE
                ;; multiply d by 12
                add a, a ; a = y*2
                add a, d ; a = y*3
                add a, a ; a = y*6
                add a, a ; a = y*12
                add a, e; a = y*12 + x
                ld l, a ; e = y*12 + x
                ld h, tiles/256
                ld a, (hl)
                ; is it moveable tile (i.e. >= NUM_NON_TILES)
                cp NUM_NON_TILES
                ; No? ok, then just move like there's no tile (i.e. ignore fact FIRE is held)
                jp c, @movements_no_tile
                ; Yes? Ok, it's a moveable tile, great, let's keep checking other conditions.
                ; 2.  is it already falling maybe? can't move a falling tile
                dec h ; (point to tiles_flags)
                ld a, (hl)
                bit 4, a
                ; if it's falling, don't permit any movements at all
                ; TODO check gameplay, is this correct? feels correct but that's just my guess.
                ret nz
                ; 3. similarly, it might not be falling yet (but the tile under
                ; it could be mid falling, so effectively we're in 'mid air') - same rule
                ; applies - you can't move it if it's in mid air
                ; TODO optimise, now we're pushing and popping HL, ugh.
                push hl
                ld a, l
                add 12
                ld l, a
                ld a, (hl)
                pop hl
                bit 4, a
                ; if it's 'effectively in mid air' then again ignore the FIRE and just
                ; move cursor as if there's no tile being controlled
                jp nz, @movements_no_tile
                ; ok fire was pressed AND we have a moveable tile under us
                ; now the excitement begins!!
                ; Mark as captured (we reset this when FIRE is let go)
                ld a, (controller_flags_tile_captured)
                and a
                jr nz, @we_already_captured_earlier
                ld a, 1
                ld (controller_flags_tile_captured), a
                ld a, 4 ; seed with 4 which is when we first change cursor colour (so that the colour change is immediate on this frame)
                ld (controller_flags_flashing_ctr), a
    @we_already_captured_earlier:
                ; are we also pressing left or right?
                ; (bit 4 or 6, with corresponding latches in bits 5 and 7)
                ld a, (controller_flags_dirs_acks)
                and %11110000
                ; if not, do nothing else
                ret z
                inc h ; (point back to tiles data)
    @check_push_left:
                ; was LEFT pressed 
                bit 4,a
                jr z, @+check_push_right ; no
                bit 5,a
                ret nz ; yes but handled already
                ; mark LEFT key as ackd (avoid repeats)
                or 32
                ld (controller_flags_dirs_acks), a
                ; get new position (left = dec l, right = inc l)
                dec l
                ld a, (hl)
                and a ; check if it is zero.  you can only push a tile into zero
                ret nz
                ; yet another edge case - even if this space is zero now, if there's something
                ; ABOVE it, that is falling INTO this space already, we can't move into it now.
                ld a, l
                sub 12
                ld l, a
                dec h ; (point to tiles_flags)
                ld a, (hl)
                ; bit 4 set -> tile at that location is falling
                bit 4, a
                ret nz
                ; all good, we can move there
                ; copy old tile to new place
                inc h ; (point back to tiles)
                ld a, l
                add 12 + 1 ; back down one row, and move right (back to our original location)
                           ; maybe we just keep a backup of this in a spare register
                ld l, a
                ld a, (hl)
                dec l
                ld (hl), a
                inc l
                ld (hl), 0
                ; TODO MAKE A QUEUE OF TILES TO CHECK, LATER? RATHER THAN IN THE MOVE HANDLER
                ; check if the one ABOVE us in the OLD location is now falling
                ld a, l
                sub 12
                ld l, a
                ld a, (hl)
                cp NUM_NON_TILES
                jr c, @+above_is_not_a_tile
                dec d
                push hl
                call check_falling_tile_hl ; FIX ME, INEFFICIENT, WE SUB 12 ABOVE AND THIS CALL JUST ADDS IT BACK AGAIN
                pop hl
                inc d
@above_is_not_a_tile:
                ; move to the new location
                dec e
                ld a,l
                add 12 - 1 ; down one row and left one column
                ld l, a
                ; check if it's falling
                call check_falling_tile_hl
                ; and mark this as our new cursor position
                ld a, e
                ld (controller_flags_x_pos), a
                ; mark the OLD location as dirty
                ; (de still contains the old location)
                inc e
                call push_dirty_tile
                ; mark the new locations as dirty also
                dec e ; TODO hm am I drawing twice, if it's also falling?
                call push_dirty_tile
                ret

    @check_push_right:
                ; was RIGHT pressed?
                bit 6,a
                ret z ; no, RIGHT was not pressed, and we already checked LEFT, so we're done
                bit 7,a
                ret nz ; yes, right was pressed, but handled already
                ; mark RIGHT key as ackd (avoid repeats)
                or 128
                ld (controller_flags_dirs_acks), a
                ; get new position (left = dec l, right = inc l)
                inc l
                ld a, (hl)
                and a ; check if it is zero.  you can only push a tile into zero
                ret nz
                ; yet another edge case - even if this space is zero now, if there's something
                ; ABOVE it, that is falling INTO this space already, we can't move into it now.
                ld a, l
                sub 12
                ld l, a
                dec h ; (point to tiles_flags)
                ld a, (hl)
                ; bit 4 set -> tile at that location is falling
                bit 4, a
                ret nz
                ; all good, we can move there
                ; copy old tile to new place
                inc h ; (point back to tiles)
                ld a, l
                add 12 - 1 ; back down one row, and move right (back to our original location)
                           ; maybe we just keep a backup of this in a spare register
                ld l, a
                ld a, (hl)
                inc l
                ld (hl), a
                dec l
                ld (hl), 0
                ; TODO MAKE A QUEUE OF TILES TO CHECK, LATER? RATHER THAN IN THE MOVE HANDLER
                ; check if the one ABOVE us in the OLD location is now falling
                ld a, l
                sub 12
                ld l, a
                ld a, (hl)
                cp NUM_NON_TILES
                jr c, @+above_is_not_a_tile
                dec d
                push hl
                call check_falling_tile_hl ; FIX ME, INEFFICIENT, WE SUB 12 ABOVE AND THIS CALL JUST ADDS IT BACK AGAIN
                pop hl
                inc d
@above_is_not_a_tile:
                ; move to the new location
                inc e
                ld a,l
                add 12 + 1 ; down one row and right one column
                ld l, a
                ; check if it's falling
                call check_falling_tile_hl
                ; and mark this as our new cursor position
                ld a, e
                ld (controller_flags_x_pos), a
                ; mark the OLD location as dirty
                ; (de still contains the old location)
                dec e
                call push_dirty_tile
                ; mark the new locations as dirty also
                inc e ; TODO hm am I drawing twice, if it's also falling?
                call push_dirty_tile
                ret

