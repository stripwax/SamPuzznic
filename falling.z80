push_falling_tiles:
                ; modifies: HL, A
                ; a contains tile x and y (YYYYxxxx)
                ld hl, (falling_tiles_tail)
                ld (hl), a
                inc hl
                ld a, 255 ; end marker
                ld (hl), a
                ld (falling_tiles_tail), hl
                ret

clear_falling_tiles:
                ; modifies: HL, A
                ld hl, falling_tiles
                ld a, 255 ; end marker
                ld (hl), a
                ld (falling_tiles_tail), hl
                ret

falling_tiles:
                defs 80 + 2 ; worst case

falling_tiles_tail: defw falling_tiles

check_falling_tile_hl:
                ; modifies: HL, A
                ; is the tile pointed (in tiles array) by hl, suspended in midair
                ; if so, update the state to say it is falling (and add it to the
                ; list of falling tiles)
                ; 1. look one row below
                ld a, l
                add 16
                ld l, a
                ld a, (hl)
                and a ; if a is zero, it means the square (below the xy) is empty space
                jr nz, @+not_falling ; not falling
                ; make sure the state is correct - zero offset for now (flag as falling)
                ; (2. go back up one row)
                ld a, l
                sub 16
                ld l, a
                ld a, 16 ; bit 4 = falling
                dec h ; (point to tiles_flags)
                ld (hl), a
                ld a, l
                jp push_falling_tiles
    @not_falling:
                ; make sure the state is correct - zero offset (and flag as not falling)
                ; (2. go back up one row)
                ld a, l
                sub 16
                ld l, a
                xor a
                dec h ; (point to tiles_flags)
                ld (hl), a
                ret

; FIXME TODO : the below combines process (update) and drawing, and is
; extra complex as a result. Should split into an update step, and a draw
; step (where the latter could be optimised for raster to avoid tearing)
; Separating might also make it easy(easier) to introduce a gameplay backdrop
; rather than plan black
draw_falling_tiles:
                ; step through list of falling tiles (x,y) coords
                ; and erase (redraw) tile rects
                ld hl, falling_tiles
    @keep_seeing_if_any_found:
                ld a, (hl)
                ; is it end marker?
                cp 255
                jr z, @none_found_and_cleanup
                ; is it a dead entry (something was falling, and has stopped now,
                ; but we've still got other falling things in this list)
                cp 254
                jr nz, @+not_dead
                inc hl
                jr @-keep_seeing_if_any_found
    @none_found_and_cleanup:
                ; on this pass we went through the whole list of falling tiles and found none
                ; Great , list can be truncated
                jp clear_falling_tiles ; this RETs

    @next:
                ld a, (hl)
                ; is it end marker?
                cp 255
                ret z ; DONE
                ; is it a dead entry
                cp 254
                jr nz, @+not_dead
                inc hl
                jr @-next
    @not_dead:
                ; a = YYYYxxxx
                ; for screen: multiply both x and y by 8 (and add GRID_X_OFFSET in x direction)
                ;             and put into de
                ; for tiles: a is (conveniently) already the low byte offset into table
                ;             so we can just put a into c (since bc is aligned to 256-bytes)
                ld c, a
                and 15
                add a,a ; a = x * 2
                add a,a; a = x * 4
                add a,a ; a = x * 8
                add a, GRID_X_OFFSET
                ld e, a ; e = x*8+GRID_X_OFFSET
                ld a, c
                and 240 ; clears carry
                rra ; a = y * 8   really just srl a but rra is cheaper when carry is already clear
                ld d, a
                ld b, tiles_flags/256
                ld a, (bc) ; the state of the tile

                if DEBUG
                ; assert that the 'falling' bit is actually set
                ; because we have had bugs here
                @fatal:
                bit 4, a
                nop
                jr z, @-fatal
                ENDIF

                ; Move the tile down 2 pixels.
                ; TODO consider using a 50fps-appropriate sequence (rather than
                ; fixed two pixels) since the gameplay is designed for 60fps.
                ; (or could just use frameskip and keep the update logic as-is)
                ; First, clear the trail - get the y offset, paint a small black rectangle
                push de
                push bc
                and 15  ; bits 0-3 are the y offset .  clears carry
                rra ; a = (y & 14) * 128 . really just srl a but rra is cheaper when carry is clear
                add d
                ld d, a
                call fillrect_16x2_black_at_de
                pop bc
                pop de
                ld a, (bc)
                and 15
                add a, 2
                cp 16
                jp c, @still_falling
                ; if we get here, it means it's at the end of this falling loop
                ; it might still be falling however (we resume next frame)
                ; but at this point we should kick off a few new processes:
                ;   1. move this tile from previous xy to new xy (which is one row lower)
                ;      also update the cursor xy to match if the cursor had captured the tile
                ;      (i.e. if this is the captured tile AND fire is held still)
                ;   2. If this tile is still falling, updating this entry to refer to the new y
                ;      (If this tile is no longer falling, mark this entry as dead)
                ;   3. check for matches (can restrict to matches involving this tile)
                ;      Note that matches checks only happen when tile is on ground (or landed on slider)
                ;      NOTE SPECIFICALLY, THAT MATCHES CHECKS ONLY HAPPEN WHEN *ALL* FALLING TILES HAVE
                ;      *STOPPED FALLING*.  not just maybe the one tiles that match; any other falling tiles
                ;      will prevent the match from happening (until they've all come to rest).
                ;   4. check for tiles above me that can now start to fall
                ;      (QUESTION: if there's a match involving this tile, will a tile in
                ;       a gap above me start to fall as part of the first frame of matching animation?
                ;       or does the matching animation play out first before any tiles above me start to fall?)
                ; ....
                push hl

                ; -----------
                ; (1d. move the cursor too, if it is captured)
                ; (it feels like this logic is in totally the wrong place)
                ; (it's also weird - rather than comparing each tile to the controller xy location,
                ;  maybe we should have a tile flag that says 'I'm the captured one')
                ld a, (controller_flags_tile_captured)
                and a
                jr z, @this_is_not_the_captured_tile
                ld a, (controller_flags_xy_pos)
                cp (hl)
                jr nz, @this_is_not_the_captured_tile
                ; this IS the captured tile
                ; move the cursor to this new spot
                add 16 ; add 1 to Y
                ld (controller_flags_xy_pos), a
    @this_is_not_the_captured_tile:
                ; -----------

                ; 1a. this xy now has zero offset (and clear falling flag)
                xor a
                ld (bc), a
                ; TODO IS THIS RIGHT? I SHOULD ALSO CHECK FOR MATCHES FIRST THOUGH RIGHT?
                ; 4a. if there's a tile above, it is now falling
                ld a, c
                sub 16 ; check ONE ROW UP
                ld c, a
                inc b ; point to tiles
                ld a, (bc)
                dec b ; point back to tile flags TODO OPTIMIZE, WE INC THEN DEC THEN INC AGAIN
                cp NUM_NON_TILES
                jr c, @finished_checking_falling_above ; jump if tile above was a non-moveable-tile
                ; tile above me can now fall into empty space, great!
                ld a, 16 ; falling but zero offset for now ; TODO IS THIS RIGHT?
                ld (bc), a
                ; point at the xy coord of the above tile and add to the falling list
                ; hl is still valid, but we can trash it here (we pop later when we need it)
                ld a, c
                call push_falling_tiles
@finished_checking_falling_above:
                ; now go back down one row
                ld a, c
                add 16
                ld c, a
                ; 1b. move the actual tile from previous xy to new xy
                inc b ; point to tiles
                ld a, (bc)
                ld l, a ; REMEMBER THIS FOR LATER.  L = THE OLD TILE
                xor a ; space is now blank
                ld (bc), a
                ; update state
                ; (1c we need to put tile A into the new xy)
                ; (2a we need to check one row below the new xy to see if the tile is still falling)
                ; is it on solid ground?  TODO test landing on a slider (horizontal or vertical)
                ld a, c
                add a, 32 ; check TWO ROWS DOWN
                ld c, a
                ; is it solid ground? TODO test landing on a slider
                ld a, (bc)
                and a
                jr nz, @landed
@not_landed:
                ; need to write where the tile is. get the correct address in bc:
                ld a, c
                sub 16 ; go back up one row (i.e. where the tile actually is now)
                ld c, a
                ; mark as zero offset and falling
                dec b
                ld a, 16
                ld (bc), a
                inc b
                ; also get the correct tile ID in a (and we still need to draw this tile...)
                ; we're now 16 rows below where we were before
                ; so add 256*8 to de
                ld a, d
                add a, 8
                ld d, a
                ld a, l ; the old tile (we preserved from earlier)

                if DEBUG
                ; assert that the tile we're drawing here is not a zero
                ; because we have had bugs here
                @fatal:
                and a
                nop
                jr z, @-fatal
                ENDIF

                ld (bc), a
                call draw_tile_at_de_tile_a
                pop hl
                ; 2b. update the y coord of the falling info to point to this new y coord
                ; should actually mark this entry as dead (after checking if it has finish falling)
                ; FIX ME PUT THE ACTUAL CHECKS HERE
                ; is it on solid ground? if so mark entry (x coord, so dec hl one more time) as dead (=64)
                ld a, (hl) ; this is the xy-coord
                add a, 16 ; add 1 to y
                ld (hl), a
                inc hl ; point to next entry in falling tiles for @next loop
                jp @-next
@landed:
                ; this is duplicate of some of logic above, but the ending is different
                ; need to write where the tile is. get the correct address in bc:
                ld a, c
                sub 16 ; go back up one row (i.e. where the tile actually is now)
                ld c, a
                ; no longer falling, so clear flag
                dec b
                xor a
                ld (bc), a
                inc b
                ; also get the correct tile ID in a (and we still need to draw this tile...)
                ; we're now 16 rows below where we were before
                ; so add 256*8 to de
                ld a, d
                add a, 8
                ld d, a
                ld a, l

                if DEBUG
                ; assert that the tile we're drawing here is not a zero
                ; because we have had bugs here
                @fatal:
                and a
                nop
                jr z, @-fatal
                ENDIF

                ld (bc), a
                call draw_tile_at_de_tile_a
                pop hl
                ; no longer falling, mark entry as dead
                ld a, 254
                ld (hl), a
                inc hl ; point to next entry in falling tiles for @next loop
                jp @-next

@still_falling:
                push hl
                or 16 ; keep the flag that says 'falling' set
                ld (bc), a ; write its new y offset back
                ; add the offset to d, the screen y location
                and 15 ; clears carry
                rra ; a*=128 . really just srl a but rra is cheaper when carry is clear
                jr nc, @+even
    @odd:
                ; I think we could only get here due to corruption
                ; as currently our y-coordinates for falling are all even-aligned
                if DEBUG
                @fatal:
                nop
                jr @-fatal
                endif

                set 7, l
    @even:
                add a, d
                ld d, a

                ; now get the tile. the tile info is 256 bytes after the falling info (handy..)
                inc b
                ld a, (bc) ; the actual tile to draw

                if DEBUG
                ; assert that the tile we're drawing here is not a zero
                ; because we have had bugs here
                @fatal:
                and a
                nop
                jr z, @-fatal
                ENDIF

                call draw_tile_at_de_tile_a
                pop hl
                inc hl ; point to next entry in falling tiles for @next loop
                jp @-next


any_tiles_falling:
                ; modifies HL, A
                ; Z = nothing falling, NZ = something falling
                ld hl, falling_tiles
    @keep_seeing_if_any_found:
                ld a, (hl)
                ; is it a valid xy coord?
                ; 255 means end-of-list and
                ; 254 means a-dead-entry-you-can-skip
                cp 255
                ret z ; end of list, nothing found, so nothing in freefall
                cp 254
                ret nz ; != 254, so a real xy => something in freefall
                inc hl
                jr @-keep_seeing_if_any_found

