clock_tick_frame: defb 0
is_panic: defb 0
panic_flash_counter: defb 0
clock_color: defb 0

init_clock:
                ; clock_tick_frame counts from 49 (or 59...) to 0 (inclusive).
                ; When counter==0, update() will reset it to FPS-1 .
                ; so when counter == FPS-1, draw() will redraw the clock.
                ; Of course, update() will also subtract 1 second from the remaining time when this happens - 
                ; but we want to force a redraw of clock on the first frame, without subtracting 1 second.
                ; 
                ; So initialize tick frame to FPS , so that update() will decrement it by 1, and draw() will see
                ; that the counter == FPS-1
                ld a, FRAMES_PER_CLOCK_SECOND
                ld (clock_tick_frame), a
                xor a
                ld (panic_flash_counter), a
                ld (is_panic), a
                ld (clock_color), a
                ret

draw_clock:
                ; if we're in full panic mode, we'll actually redraw the time every 4 frames
                ; (as well as if clock_frame == 0)
                ld a, (is_panic)
                and a
                jp nz, @check_panic_clock

                ; not a panic mode, so just redraw clock when frame counter resets
                ld a, (clock_tick_frame)
                cp FRAMES_PER_CLOCK_SECOND-1
                ret nz

                ld a, (clock_color)
                ld c, a

        @_draw_clock_main:
                ; minutes
                ld a, (clock_min_bcd)
                ; top minute decimal is ignored
                and 15
                push bc ; color
                ld de, CLOCK_Y_OFFSET*128
                pop bc ; color
                push bc ; color
                call fatnum_digit_a_variant_c_xy_de

                ; seconds
                ld a, (clock_sec_bcd)
                ; top second decimal
                and 240
                rrca
                rrca
                rrca
                rrca
                ld de, CLOCK_Y_OFFSET*128 + 12 ; y*128+(x/2)
                pop bc ; color
                push bc ; color
                call fatnum_digit_a_variant_c_xy_de
                ; bottom second decimal
                ld a, (clock_sec_bcd)
                and 15
                ld de, CLOCK_Y_OFFSET*128 + 20 ; y*128+(x/2)
                pop bc ; color
                call fatnum_digit_a_variant_c_xy_de ; TODO optimize maybe JP rather than call+ret?
                ret

update_clock:
                ld a, (clock_tick_frame)
                dec a
                ld (clock_tick_frame), a
                ; If we are now < 0 then a full second has elapsed
                ; (if we are not < 0, then we're between second ticks
                ; and we've done all the updates we need to do)
                ret p ; not negative i.e. not < 0
                ld a, FRAMES_PER_CLOCK_SECOND-1
                ld (clock_tick_frame), a

    @next_sec:
                ; decrement number of remaining seconds
                ld a, (clock_sec_bcd)
                sub 1
                daa
                ; did we underflow (0 -> 99) ?
                jr c, @+next_min
                ; no? ok, just save back the number of seconds
                ld (clock_sec_bcd), a

                ; quick check - are we in panic mode?
                ld a, (clock_min_bcd)
                and a
                ret nz ; time >= 1:00 remaining
                ld a, (clock_sec_bcd)
                cp 0x31 ; bcd
                ret nc ; time >= 0:30 remaining
                ; either mild panic or full panic!
                ; assume mild panic
                cp 0x11 ; bcd
                jr nc, @mild_panic ; 0:11 <= time <= 0:30 remaining, mild panic only
                ld a, 1
                ld (is_panic), a ; time <= 0:10 remaining!! panic!!
                xor a
                ld (clock_color), a
                ret
    @mild_panic:
                ; <= 30 seconds remaining. red clock!
                ld a, 1
                ld (clock_color), a
                ret

    @next_min:
                ld a, (clock_min_bcd)
                and a; set Z if a is zero
                ret z ; clock is done, we're on last minute and seconds just decremented to 0
                sub 1
                daa
                ld (clock_min_bcd), a
                ld a, 0x59 ; bcd
                ld (clock_sec_bcd), a
                ret

@check_panic_clock:
                ; called each frame to render a flashing clock (<10 seconds remaining)
                ld a, (clock_tick_frame)
                cp FRAMES_PER_CLOCK_SECOND-1
                jr nz, @+flashing

                ; not flashing, but need to redraw anyway
                ld a, (panic_flash_counter)
                inc a
                ld (panic_flash_counter), a
                jp @draw_panic_clock

        @flashing:
                ; only redraw every 4 frames (color change)
                ld a, (panic_flash_counter)
                inc a
                ld (panic_flash_counter), a
                and 3
                ret nz  ; this is not frame 0 (it's frame 1/2/3) so do NOT redraw clock
                ; get the color (0 or 1) from the 2th bit of the counter
        @draw_panic_clock:
                ld a, (panic_flash_counter)
                rrca
                rrca
                and 1
                ld c, a
                jp @_draw_clock_main

check_clock_30:
                ret

check_clock_game_over:
                ret

