; score is up to 9999990 (according to Puzznic arcade game)
; represent as bcd, with one trailing 0 digits

score_bcd_1: defb 0
score_bcd_2: defb 0
score_bcd_3: defb 0

init_score:
        ; start of game but not between levels!
        xor a
        ld (score_bcd_1), a
        ld (score_bcd_2), a
        ld (score_bcd_3), a
        ret

add_score:
        ; add a bcd amount in bc to the score
        ld a, (score_bcd_3)
        add a, c
        daa
        ld (score_bcd_3), a
        ld a, (score_bcd_2)
        adc b
        daa
        ld (score_bcd_2), a
        ret nc
        ld a, (score_bcd_1)
        adc 0
        daa
        ld (score_bcd_1), a
        ret

render_score:
        ; skip leading zeros until we find a non-zero
        ; and then don't skip anything
        ld de, 0
        ld a, (score_bcd_1)
        and a
        jr z, @+skip_bcd1
        and 240
        jr z, @+skip_bcd1_hi
        rrca
        rrca
        rrca
        rrca
        push de
        call digit_a_xy_de
        pop de
    @skip_bcd1_hi:
        ld e, 4
        ld a, (score_bcd_1)
        and 15
        push de
        call digit_a_xy_de
        pop de
    @skip_bcd1_do_bcd2:
        ld e, 8
        ld a, (score_bcd_2)
        and 240
        rrca
        rrca
        rrca
        rrca
        push de
        call digit_a_xy_de
        pop de
    @skip_bcd2_hi:
        ld e, 12
        ld a, (score_bcd_2)
        and 15
        push de
        call digit_a_xy_de
        pop de
    @skip_bcd2_do_bcd3:
        ld e, 16
        ld a, (score_bcd_3)
        and 240
        rrca
        rrca
        rrca
        rrca
        push de
        call digit_a_xy_de
        pop de
    @skip_bcd3_hi:
        ld e, 20
        ld a, (score_bcd_3)
        and 15
        push de
        call digit_a_xy_de
        pop de
    @final_zero:
        ; always render a final '0' character
        ; todo, this never changes, so maybe only render
        ; it when first drawing the screen
        ld e, 24
        ld a, 0
        ;call digit_a_xy_de ; optimize, JP instead of call+ret?
        ;ret
        jp digit_a_xy_de

    @skip_bcd1:
        ; we skipped two leading zeros, we might need to skip more.
        ld a, (score_bcd_2)
        and a
        jr z, @+skip_bcd2
        and 240
        jr z, @-skip_bcd2_hi
        jp @-skip_bcd1_do_bcd2
    @skip_bcd2:
        ; we skipped four leading zeros, we might need to skip more.
        ld a, (score_bcd_3)
        and a
        jr z, @-final_zero
        and 240
        jr z, @-skip_bcd3_hi
        jp @-skip_bcd2_do_bcd3
