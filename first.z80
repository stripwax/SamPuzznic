INCLUDE "DEBUG_DEFS.z80"
INCLUDE "consts.z80"
INCLUDE "SAM_IO_defs.z80"

dump 1,0    ; Dump objectcode to Page 1 with no offset, ie 32768 in BASIC's terminology
autoexec    ; Set to automatically load and call when sent to SimCoup√©
org 32768   ; Org to same address.  No clever paging needed here.

init:
				di
    @set_low_page:
				ld a,8+32						; Set low pages as screen buffer, with ROM paged out
				out (LMPR),a                     ; LMPR - pages A and B of address space
                ld a, 8+96                      ; Set video output to same pages as above, with mode 4
				out (VMPR),a                     ; VMPR - mapped to video output - same as above
    @set_palette:
                ld hl, palette_bottom+15
                ld bc, 16*256+248
                otdr
    @enable_video:
                ld a, %00000000 ; black border, screen enabled
                out (BORDER),a
	@set_stack:
				ld sp,stack						; Use our own stack, point to below bottom of stack
    @go:
				jp main
    
    @stack_space:
                defs 64

stack:
        ; point past stack space



main:
                ; clock_tick_frame counts from 49 to 0 (inclusive).
                ; but 0 means "time to redraw the clock"                
                ; wait loop for setting breakpoints in simice
                IF DEBUG==1
                    IF DEBUG_WAIT_ON_START==1
                    call debug_wait_for_a_bit
                    ENDIF
                ENDIF

                xor a
                ld (clock_tick_frame), a
                ld (clock_changed), a ; poke a nop here

                call clear_dirty_tiles_list
                call clear_draw_list
                call clear_falling_tiles
                call clear_queue_tiles_to_check

                call debug_memcpy_level_data
                call init_game_state
                call init_score
                call render_screen_layout
                call render_puzzle_tiles ; also counts (and renders) remaining tiles
                call sfx_init
                call game_loop
                ; when game_loop exits, you're either onto the next level, or you died
                ld a, (level_clear_process)
                cp 2
                jp z, @+next_level
                cp 3
                jp z, @+you_died
    @next_level:
                ld a, (level_number)
                inc a
                ld (level_number), a
                jp main  ; round again!

    @you_died:
                ; TODO!
                jp @-you_died


INCLUDE "match.z80"
INCLUDE "input.z80"
INCLUDE "input_raw.z80"
INCLUDE "draw.z80"
INCLUDE "game_state.z80"
INCLUDE "clock.z80"
INCLUDE "vsync_utils.z80"
INCLUDE "slider.z80"
INCLUDE "cursor.z80"
INCLUDE "music.z80"
INCLUDE "sfx.z80"
INCLUDE "dirty_tiles.z80"
INCLUDE "falling.z80"
INCLUDE "score.z80"
INCLUDE "bonus.z80"
INCLUDE "remaining.z80"
INCLUDE "puzzle_init.z80"
INCLUDE "clear.z80"
INCLUDE "puzzles.z80"
INCLUDE "text.z80"
INCLUDE "bitmaps.z80"
INCLUDE "palette.z80"
INCLUDE "game_loop.z80"

IF DEBUG==1
INCLUDE "debug.z80"
ENDIF

